<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>Introdução ao geoprocessamento para Etnobiologia e Conservação da Biodiversidade</title>
    <meta charset="utf-8" />
    <meta name="author" content="Maurício H. Vancine" />
    <link href="libs/remark-css/metropolis.css" rel="stylesheet" />
    <script src="https://use.fontawesome.com/5235085b15.js"></script>
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Introdução ao geoprocessamento para Etnobiologia e Conservação da Biodiversidade <br><br>
## 3 Estrutura de dados <br><br> xaringan [presentation ninja]
### Maurício H. Vancine
### 30/09/2019

---




class: clear, center, middle
background-image: url(https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/Data-Types-350x300.png)
background-size: 400px
background-position: 50% 50%

---

# 3 Estrutura e manejo de dados
## Tópicos
3.1 Atributos dos objetos
&lt;br&gt;
3.2 Modos dos objetos
&lt;br&gt;
3.3 Modos dos objetos: numérico (**numeric**)
&lt;br&gt;
3.4 Modos dos objetos: caracter (**character**)
&lt;br&gt;
3.5 Modos dos objetos: lógico (**logical**)
&lt;br&gt;
3.6 Estrutura dos objetos
&lt;br&gt;
3.7 Estrutura dos objetos: vetor (**vector**)
&lt;br&gt;
3.8 Estrutura dos objetos: fator (**factor**)
&lt;br&gt;
3.9 Estrutura dos objetos: matriz (**matrix**)
&lt;br&gt; 
3.10 Estrutura dos objetos: data frame (**data frame**)
&lt;br&gt; 
3.11 Estrutura dos objetos: lista (**list**)

---

# 3.1 Atributos dos objetos

## Atribuição

&lt;br&gt;&lt;br&gt;

## **palavra &lt;- dados**

--

&lt;br&gt;&lt;br&gt;


```r
## atribuicao - simbolo (&lt;-)
obj_10 &lt;- 10 
obj_10
```

```
## [1] 10
```

---

# 3.1 Atributos dos objetos

## Atributos dos objetos no R

### Objetos possuem **três características**:

&lt;br&gt;

--

### 1. **Nome**: palavra que o R reconhece os dados atribuídos

--

### 2. **Conteúdo**: dados em si

--

### 3. **Atributos**: modos (*natureza*) e estruturas (*organização*)

---

# 3.2 Modos dos objetos

## Modos (*natureza*): numeric, character e logical

--

### **Natureza** dos **elementos** que compõem os objetos

---

# 3.3 Modos dos objetos: numeric

## **Numeric**: números inteiros ou decimais

```r
# numeric
obj_num &lt;- 1
obj_num
```

```
## [1] 1
```
--

```r
# mode
mode(obj_num)
```

```
## [1] "numeric"
```

---

# 3.4 Modos dos objetos: character

### 2. **character**: texto

--

```r
# character
obj_cha &lt;- "a" # atencao para as aspas
obj_cha
```

```
## [1] "a"
```
--

```r
# mode
mode(obj_cha)
```

```
## [1] "character"
```

---

# 3.5 Modos dos objetos: logical

### 3. **logical**: assume apenas dois valores (booleano)

--


```r
# logical
obj_log &lt;- TRUE # maiusculas e sem aspas
obj_log
```

```
## [1] TRUE
```
--

```r
# mode
mode(obj_log)
```

```
## [1] "logical"
```

---

# 3.5 Modos dos objetos: resumindo

## Resumindo:

### A **natureza** dos **elementos** irá definir os **modos** dos objetos

--

&lt;br&gt;&lt;br&gt;

## Modos (*natureza*) são **três**: 

### numeric (**número**): *1*
### character (**texto**): *"a"* ou *"2500"*
### logical (**lógico**): *TRUE* ou *FALSE*

---

class: inverse, middle, center

# Dúvidas?

---

# 3.6 Estrutura dos objetos

## Estruturas (*organização*): vector, factor, matrix, data frame e list

--

### Organização (**modos** e **dimensionalidade**) dos elementos dos objetos

--

background-image: url(https://devopedia.org/images/article/46/7262.1526126010.png)
background-size: 650px
background-position: 50% 90%

---

background-image: url(http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png)
background-size: 800px
background-position: 50% 50%

# 3.6 Estrutura dos objetos

---

background-image: url(http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png)
background-size: 800px
background-position: 50% 50%

# 3.7 Estrutura dos objetos: vector

## **1. Vector**

---

# 3.7 Estrutura dos objetos: vector

## **1. Vector**: homogêneo (*um modo*) e unidimensional (*uma dimensão*)

--

### O **vetor** representa medidas de uma **variável quantitativa** (discretas ou contínuas) ou **descrição** (informações em texto)

--

### Ex.: medidas tomadas em campo ao longo de uma amostragem de 5 meses

--

1. Amostragens: {"amostra_01", "amostra_02", "amostra_03", "amostra_04", "amostra_05"}

--

2. Temperatura: {15, 18, 20, 22, 18}

--

3. Abertura do dossel: {0.37, 0.45, 0.65, 0.75, 0.40}

--

4. Abundância de uma espécie: {6, 3, 0, 0, 2}

---

# 3.7 Estrutura dos objetos: vector

### Há diversas formas de se criar um **vetor**:

--

### 1. Concatenar elementos

```r
# concatenar elementos
temp &lt;- c(15, 18, 20, 22, 18)
temp
```

```
## [1] 15 18 20 22 18
```
&lt;br&gt;
--

```r
amos &lt;- c("amostra_01", "amostra_02", "amostra_03", "amostra_04")
amos
```

```
## [1] "amostra_01" "amostra_02" "amostra_03" "amostra_04"
```

---

# 3.7 Estrutura dos objetos: vector

### Há diversas formas de se criar um **vetor**:

### 2. Sequência

```r
# sequencia unitaria (x1:x2)
se &lt;- 1:10
se
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```
&lt;br&gt;
--

```r
# sequencia com diferentes espacamentos 
se.e &lt;- seq(from = 0, to = 100, by = 10) 
se.e
```

```
##  [1]   0  10  20  30  40  50  60  70  80  90 100
```

---

# 3.7 Estrutura dos objetos: vector

### Há diversas formas de se criar um **vetor**:

### 3. Repetição

```r
# repeticao
# rep(x, times) # repete x tantas vezes
# rep(x, each) # retete x tantas vezes de cada

rep_times &lt;- rep(x = c(1, 2), times = 5)
rep_times
```

```
##  [1] 1 2 1 2 1 2 1 2 1 2
```
&lt;br&gt;
--

```r
rep_each &lt;- rep(x = c("a", "b"), each = 5)
rep_each
```

```
##  [1] "a" "a" "a" "a" "a" "b" "b" "b" "b" "b"
```

---

# 3.7 Estrutura dos objetos: vector

### Há diversas formas de se criar um **vetor**:

### 4. "Colar" palavras com uma sequência numérica


```r
# palavra e sequencia numerica - sem separacao
am1 &lt;- paste("amostra", 1:6, sep = "0")
am1
```

```
## [1] "amostra01" "amostra02" "amostra03" "amostra04" "amostra05" "amostra06"
```
&lt;br&gt;
--

```r
# palavra e sequencia numerica - separacao por "_"
am2 &lt;- paste("amostra", 1:6, sep = "_0")
am2
```

```
## [1] "amostra_01" "amostra_02" "amostra_03" "amostra_04" "amostra_05"
## [6] "amostra_06"
```

---

class: inverse, middle, center

# Dúvidas?

---

class: inverse, middle, center

# E se eu criar um vetor com elementos de *modos diferentes*?

---

# 3.7 Estrutura dos objetos: vector

## Vetor com elementos de **modos diferentes**:

--

&lt;br&gt;


```r
ve &lt;- c(1, "a", 3)
ve
```

```
## [1] "1" "a" "3"
```
--
&lt;br&gt;

```r
ve &lt;- c(1, "a", TRUE)
ve
```

```
## [1] "1"    "a"    "TRUE"
```

---

# Coerção

## Mudança do **modo** dos elementos para um **mesmo modo**

&lt;br&gt;&lt;br&gt;&lt;br&gt;

--

## Essa mudança segue essa ordem:

### `DOMINANTE` **character** &gt;&gt; **numeric** &gt;&gt; **logical** `RECESSIVO`

---

# Coerção

## **character** &gt;&gt; **numeric**


```r
ve &lt;- c("a", 1)
ve
```

```
## [1] "a" "1"
```
--

```r
class(ve)
```

```
## [1] "character"
```

```r
mode(ve)
```

```
## [1] "character"
```

---

# Coerção

## **numeric** &gt;&gt; **logical**


```r
ve &lt;- c(1, TRUE)
ve
```

```
## [1] 1 1
```
--

```r
class(ve)
```

```
## [1] "numeric"
```

```r
mode(ve)
```

```
## [1] "numeric"
```

---

# Coerção

## **character** &gt;&gt; **logical**


```r
ve &lt;- c("a", TRUE)
ve
```

```
## [1] "a"    "TRUE"
```
--

```r
class(ve)
```

```
## [1] "character"
```

```r
mode(ve)
```

```
## [1] "character"
```

---

# Coerção

## **character** &gt;&gt; **numeric** &gt;&gt; **logical**


```r
ve &lt;- c("a", 1, TRUE)
ve
```

```
## [1] "a"    "1"    "TRUE"
```
--

```r
class(ve)
```

```
## [1] "character"
```

```r
mode(ve)
```

```
## [1] "character"
```

---

# Conversão

## Podemos **forçar** um vetor a ter um **modo específico**

--

### Ideia semelhante: mudar o **tipo da célula** numa planilha eletrônica

--

### Vetor **numeric**

```r
ve &lt;- c(0, 1, 2, 3, 4)
ve
```

```
## [1] 0 1 2 3 4
```
--

```r
mode(ve)
```

```
## [1] "numeric"
```

---

# Conversão

## Podemos **forçar** um vetor a ter um **modo específico**

### Forçar a ser **character**, vindo de um **numeric**

```r
ve
```

```
## [1] 0 1 2 3 4
```
--

```r
ve_ch &lt;- as.character(ve)
ve_ch
```

```
## [1] "0" "1" "2" "3" "4"
```
--

```r
mode(ve_ch)
```

```
## [1] "character"
```

---

# Conversão

## Podemos **forçar** um vetor a ter um **modo específico**

### Forçar a ser **logical**, vindo de um **numeric**

```r
ve
```

```
## [1] 0 1 2 3 4
```
--

```r
ve_lo &lt;- as.logical(ve)
ve_lo
```

```
## [1] FALSE  TRUE  TRUE  TRUE  TRUE
```
--

```r
mode(ve_lo)
```

```
## [1] "logical"
```

---

# Conversão

## Podemos **forçar** um vetor a ter um **modo específico**

### Forçar a ser **numeric**, vindo de um **character**

```r
ve_ch
```

```
## [1] "0" "1" "2" "3" "4"
```
--

```r
ve_nu &lt;- as.numeric(ve_ch)
ve_nu
```

```
## [1] 0 1 2 3 4
```
--

```r
mode(ve_nu)
```

```
## [1] "numeric"
```

---

class: inverse, middle, center

# Dúvidas?

---

background-image: url(http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png)
background-size: 800px
background-position: 50% 50%

# 3.8 Estrutura dos objetos: factor

## **2. Factor**

---

# 3.8 Estrutura dos objetos: factor

## **2. Factor**: homogêneo (*um modo* - sempre *numeric*), unidimensional (*uma dimensão*) e possui ainda **levels** (níveis)

--

### O **factor** representa medidas de uma **variável qualitativa**, podendo ser **nominal** ou **ordinal**

--

### Ex.: medidas tomadas em campo ao longo de uma amostragem de 6 meses

--

1. Amostragens: {"amostra_01", "amostra_02", "amostra_03", "amostra_04", "amostra_05"}

--

2. Tipo de floresta: {fechada, fechada, aberta, aberta, aberta}

--

3. Abundância de uma espécie: {alta, media, baixa, baixa, media}

---

# 3.8 Estrutura dos objetos: factor

## **2. Factor nominal**: variáveis nominais


```r
fa_no &lt;- factor(x = c("fechada", "fechada", "aberta", "aberta", "aberta"),
                levels = c("aberta", "fechada"))
fa_no
```

```
## [1] fechada fechada aberta  aberta  aberta 
## Levels: aberta fechada
```
--

```r
levels(fa_no)
```

```
## [1] "aberta"  "fechada"
```
---

# 3.8 Estrutura dos objetos: factor

## **2. Factor ordinal**: variáveis ordinais

```r
fa_or &lt;- factor(x = c("alta", "media", "baixa", "baixa", "media"),
                levels = c("baixa", "media", "alta"), ordered = TRUE)
fa_or
```

```
## [1] alta  media baixa baixa media
## Levels: baixa &lt; media &lt; alta
```
--

```r
levels(fa_or)
```

```
## [1] "baixa" "media" "alta"
```

---

# 3.8 Estrutura dos objetos: factor

## **2. Factor** conversão

--

### Criar um vetor **character**

```r
ve_ch &lt;- c("alta", "media", "baixa", "baixa", "media")
ve_ch
```

```
## [1] "alta"  "media" "baixa" "baixa" "media"
```
--

```r
mode(ve_ch)
```

```
## [1] "character"
```
--

```r
class(ve_ch)
```

```
## [1] "character"
```

---

# 3.8 Estrutura dos objetos: factor

## **2. Factor**: conversão

--

### Forçar a ser **factor nominal**

```r
fa_no &lt;- as.factor(ve_ch)
fa_no
```

```
## [1] alta  media baixa baixa media
## Levels: alta baixa media
```
--

```r
levels(fa_no)
```

```
## [1] "alta"  "baixa" "media"
```
--

```r
class(fa_no)
```

```
## [1] "factor"
```

---

background-image: url(http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png)
background-size: 800px
background-position: 50% 50%

# 3.9 Estrutura dos objetos: matrix

## **3. Matrix**

---

# 3.9 Estrutura dos objetos: matrix

## **3. Matrix**: homogêneo (*um modo*) e bidimensional (*duas dimensão*)

--

### A **matrix** representa os dados no formato de **tabela**, com **linhas** e **colunas**

--

### As **linhas** representam **unidades amostrais** (locais, transectos, parcelas) e as **coluncas** representam **variáveis quantitativas** (discretas ou contínuas) ou **descrições** (informações em texto)

---

# 3.9 Estrutura dos objetos: matrix

## **3. Matrix**: homogêneo (*um modo*) e bidimensional (*duas dimensão*)

### Ex.: espécies amostradas 5 locais

--

background-image: url(https://www.neonscience.org/sites/default/files/images/R/matrix.png)
background-size: 630px
background-position: 130% 150%

---

class: inverse, middle, center

# Esse formato lembra algo?

---

background-image: url(https://i.blogs.es/5415b1/excel-calc/1366_2000.png)
background-size: 700px
background-position: 50% 60%

# 3.9 Estrutura dos objetos: matrix

## **3. Matrix**: planilhas eletrônicas

---

class: inverse, center, middle
background-image: url(https://media.giphy.com/media/xT0xeJpnrWC4XWblEk/giphy.gif)
background-size: 700px
background-position: 50% 60%

---

# 3.9 Estrutura dos objetos: matrix

## Há **duas formas** de se construir uma **matrix** no R:

### 1 Dispondo elementos

`matrix`: dispõem um vetor em um certo número de linhas e colunas


```r
# matriz - funcao matrix
# vetor
ve &lt;- 1:12
```
--

```r
# matrix - preenchimento por linhas - horizontal
ma_row &lt;- matrix(data = ve, nrow = 4, ncol = 3, byrow = TRUE)
ma_row
```

```
##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6
## [3,]    7    8    9
## [4,]   10   11   12
```

---

# 3.9 Estrutura dos objetos: matrix

## Há **duas formas** de se construir uma **matrix** no R:

### 1 Dispondo elementos

`matrix`: dispõem um vetor em um certo número de linhas e colunas


```r
# matriz - funcao matrix
# vetor
ve &lt;- 1:12
```
--

```r
# matrix - preenchimento por colunas - vertical
ma_col &lt;- matrix(data = ve, nrow = 4, ncol = 3, byrow = FALSE)
ma_col
```

```
##      [,1] [,2] [,3]
## [1,]    1    5    9
## [2,]    2    6   10
## [3,]    3    7   11
## [4,]    4    8   12
```

---

# 3.9 Estrutura dos objetos: matrix

## Há **duas formas** de se construir uma **matrix** no R:

###  2 Combinando vetores
`rbind`: combina vetores por linha, i.e., vetor embaixo do outro

`cbind`: combina vetores por coluna, i.e., vetor ao lado do outro


```r
# criar dois vetores
vec_1 &lt;- c(1, 2, 3)
vec_2 &lt;- c(4, 5, 6)
```
--

```r
# combinar por linhas - vertical - um embaixo do outro
ma_rbind &lt;- rbind(vec_1, vec_2)
ma_rbind
```

```
##       [,1] [,2] [,3]
## vec_1    1    2    3
## vec_2    4    5    6
```

---

# 3.9 Estrutura dos objetos: matrix

## Há **duas formas** de se construir uma **matrix** no R:

###  2 Combinando vetores
`rbind`: combina vetores por linha, i.e., vetor embaixo do outro

`cbind`: combina vetores por coluna, i.e., vetor ao lado do outro


```r
# criar dois vetores
vec_1 &lt;- c(1, 2, 3)
vec_2 &lt;- c(4, 5, 6)
```
--

```r
# combinar por colunas - horizontal - um ao lado do outro
ma_cbind &lt;- cbind(vec_1, vec_2)
ma_cbind
```

```
##      vec_1 vec_2
## [1,]     1     4
## [2,]     2     5
## [3,]     3     6
```

---

# 3.9 Estrutura dos objetos: matrix

## Coerção

```r
# criar dois vetores
vec_ch &lt;- c("sp1", "sp2", "sp3")
vec_nu &lt;- c(4, 5, 6)
```
--

```r
# combinar por colunas - horizontal - um ao lado do outro
ma_ch &lt;- cbind(vec_ch, vec_nu)
ma_ch
```

```
##      vec_ch vec_nu
## [1,] "sp1"  "4"   
## [2,] "sp2"  "5"   
## [3,] "sp3"  "6"
```

---

# 3.9 Estrutura dos objetos: matrix

## **3. Matrix**: homogêneo (*um modo*), bidimensional (*duas dimensão*)

## Essa mudança também segue a ordem:

### `DOMINANTE` **character** &gt;&gt; **numeric** &gt;&gt; **logical** `RECESSIVO`

---

background-image: url(http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png)
background-size: 800px
background-position: 50% 50%

# 3.10 Estrutura dos objetos: array

## **4. Array**

---

# 3.10 Estrutura dos objetos: array

## **4. Array**: homogêneo (*um modo*) e multidimensional (*mais que duas dimensões*)

--

### O **array** representa combinação de **tabelas**, com **linhas**, **colunas** e **dimensões**

--

background-image: url(https://www.neonscience.org/sites/default/files/images/R/array.png)
background-size: 480px
background-position: 50% 100%

---

class: inverse, center, middle
background-image: url(https://media.giphy.com/media/11ahZZugJHrdLO/giphy.gif)
background-size: 700px
background-position: 50% 50%

---

# 3.10 Estrutura dos objetos: array

## Há **uma forma** de se construir um **array** no R:

### 1 Dispondo elementos

`array`: dispõem um vetor em um certo número de linhas, colunas e dimensões....


```r
# vetor
ve &lt;- 1:8
ve
```

```
## [1] 1 2 3 4 5 6 7 8
```

---

background-image: url(https://www.neonscience.org/sites/default/files/images/R/array.png)
background-size: 350px
background-position: 80% 85%


# 3.10 Estrutura dos objetos: array

## Há **uma forma** de se construir um **array** no R:

### 1 Dispondo elementos

`array`: dispõem um vetor em um certo número de linhas, colunas e dimensões....

```r
ar &lt;- array(data = ve, dim = c(2, 2, 2))
ar
```

```
## , , 1
## 
##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4
## 
## , , 2
## 
##      [,1] [,2]
## [1,]    5    7
## [2,]    6    8
```

---

background-image: url(http://www.simonqueenborough.info/R/basic/img/data/data-array.png)
background-size: 700px
background-position: 50% 120%

# 3.10 Estrutura dos objetos

## Até o momento vimos **estruturas homogêneas**

---

background-image: url(http://www.simonqueenborough.info/R/basic/img/data/data-same.png)
background-size: 700px
background-position: 50% 120%

# 3.10 Estrutura dos objetos

## Agora veremos as **estruturas heterogêneos**

---

background-image: url(http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png)
background-size: 800px
background-position: 50% 50%

# 3.10 Estrutura dos objetos: data frame

## **5. Data frame**

---

# 3.10 Estrutura dos objetos: data frame

## **5. Data frame**: heterogêneo (*mais de um modo*) e bidimensional (*duas dimensões*)

--

### O **data frame** representa dados no formato de **tabela**, com **linhas** e **colunas**

--

### As **linhas** representam **unidades amostrais** (locais, transectos, parcelas) e as **colunas** representam **descrições** (informações em texto), **variáveis quantitativas** (discretas ou contínuas) e/ou **variáveis qualitativas** (nominais ou ordinais)

---

background-image: url(http://s3.amazonaws.com/libapps/accounts/17830/images/r_data_structures.png)
background-size: 800px
background-position: 50% 60%

# 3.10 Estrutura dos objetos: data frame

## **5. Data frame**: heterogêneo (*mais de um modo*) e bidimensional (*duas dimensões*)

---

class: inverse, middle, center

# Esse formato também lembra algo?

---

background-image: url(https://i.blogs.es/5415b1/excel-calc/1366_2000.png)
background-size: 700px
background-position: 50% 60%

# 3.10 Estrutura dos objetos: data frame

## **5. Data frame**: planilhas eletrônicas

---

class: inverse, middle, center

# Ótimo, porque é justamente esse o formato de entrada dos dados de planilhas eletrônicas!

---

class: inverse, center, middle
background-image: url(https://media.giphy.com/media/3o7TKSjRrfIPjeiVyM/giphy.gif)
background-size: 700px

---

# 3.10 Estrutura dos objetos: data frame

## Há **uma forma** de se construir um **data frame** no R:

### 1 Combinando vetores horizontalmente

`data.frame`: combina vetores horizontalmente, um ao lado do outro. Semelhante à função `cbind`


```r
# criar três vetores
vec_ch &lt;- c("sp1", "sp2", "sp3")
vec_nu &lt;- c(4, 5, 6)
vec_fa &lt;- factor(c("campo", "floresta", "floresta"))
```
--

```r
# data.frame - combinar por colunas - horizontal - um ao lado do outro
df &lt;- data.frame(vec_ch, vec_nu, vec_fa)
df
```

```
##   vec_ch vec_nu   vec_fa
## 1    sp1      4    campo
## 2    sp2      5 floresta
## 3    sp3      6 floresta
```

---

# 3.10 Estrutura dos objetos: data frame

## Há **uma forma** de se construir um **data frame** no R:

### 1 Combinando vetores horizontalmente

### Também podemos informar o nome das colunas

--

```r
# data.frame
df &lt;- data.frame(especies = vec_ch, 
                 abundancia = vec_nu, 
                 vegetacao = vec_fa)
df
```

```
##   especies abundancia vegetacao
## 1      sp1          4     campo
## 2      sp2          5  floresta
## 3      sp3          6  floresta
```

---

# 3.10 Estrutura dos objetos: data frame

## Coerção de **data frame** para **matrix**

```r
# coercao de data frame para matrix
ma &lt;- as.matrix(df)
ma
```

```
##      especies abundancia vegetacao 
## [1,] "sp1"    "4"        "campo"   
## [2,] "sp2"    "5"        "floresta"
## [3,] "sp3"    "6"        "floresta"
```

### Seguindo aquela hierarquia
### `DOMINANTE` **character** &gt;&gt; **numeric** &gt;&gt; **logical** `RECESSIVO`

---

# 3.10 Estrutura dos objetos: data frame

## Coerção de **matrix** para **data frame**

```r
# coercao de matrix para data frame
df &lt;- as.data.frame(ma)
df
```

```
##   especies abundancia vegetacao
## 1      sp1          4     campo
## 2      sp2          5  floresta
## 3      sp3          6  floresta
```
--

```r
str(df)
```

```
## 'data.frame':	3 obs. of  3 variables:
##  $ especies  : Factor w/ 3 levels "sp1","sp2","sp3": 1 2 3
##  $ abundancia: Factor w/ 3 levels "4","5","6": 1 2 3
##  $ vegetacao : Factor w/ 2 levels "campo","floresta": 1 2 2
```

---

# 3.10 Estrutura dos objetos: data frame

## Coerção de **matrix** para **data frame**

```r
# coercao de matrix para data frame
df &lt;- as.data.frame(ma, stringsAsFactors = FALSE)
df
```

```
##   especies abundancia vegetacao
## 1      sp1          4     campo
## 2      sp2          5  floresta
## 3      sp3          6  floresta
```
--

```r
str(df)
```

```
## 'data.frame':	3 obs. of  3 variables:
##  $ especies  : chr  "sp1" "sp2" "sp3"
##  $ abundancia: chr  "4" "5" "6"
##  $ vegetacao : chr  "campo" "floresta" "floresta"
```

---

# 3.10 Estrutura dos objetos: data frame

## **data frame** vs **cbind**

### Criação dos vetores

```r
## vetores
pa &lt;- paste("parcela", 1:4, sep = "_")
pa
```

```
## [1] "parcela_1" "parcela_2" "parcela_3" "parcela_4"
```
--

```r
pe &lt;- sample(0:1, 4, rep = TRUE)
pe
```

```
## [1] 1 1 0 0
```
--

```r
tr &lt;- factor(rep(c("trat", "cont"), each = 2))
tr
```

```
## [1] trat trat cont cont
## Levels: cont trat
```

---

# 3.10 Estrutura dos objetos: data frame

### Qual a diferença?


```r
# uniao de vetores
df &lt;- data.frame(pa, pe, tr)
df
```

```
##          pa pe   tr
## 1 parcela_1  1 trat
## 2 parcela_2  1 trat
## 3 parcela_3  0 cont
## 4 parcela_4  0 cont
```
--

```r
str(df)
```

```
## 'data.frame':	4 obs. of  3 variables:
##  $ pa: Factor w/ 4 levels "parcela_1","parcela_2",..: 1 2 3 4
##  $ pe: int  1 1 0 0
##  $ tr: Factor w/ 2 levels "cont","trat": 2 2 1 1
```

---

# 3.10 Estrutura dos objetos: data frame

### Qual a diferença?


```r
# uniao de vetores
df.c &lt;- cbind(pa, pe, tr)
df.c
```

```
##      pa          pe  tr 
## [1,] "parcela_1" "1" "2"
## [2,] "parcela_2" "1" "2"
## [3,] "parcela_3" "0" "1"
## [4,] "parcela_4" "0" "1"
```
--

```r
str(df.c)
```

```
##  chr [1:4, 1:3] "parcela_1" "parcela_2" "parcela_3" "parcela_4" "1" ...
##  - attr(*, "dimnames")=List of 2
##   ..$ : NULL
##   ..$ : chr [1:3] "pa" "pe" "tr"
```

---

background-image: url(http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png)
background-size: 800px
background-position: 50% 50%

# 3.11 Estrutura dos objetos: list

## **6. List**

---

# 3.11 Estrutura dos objetos: list

## **6. List**: heterogêneo (*mais de um modo*) e unidimensional (*uma dimensão*)

--

### Tipo **especial de vetor** que aceita **objetos** como **elementos**

--

### Estrutura de dados utilizado para **agrupar objetos**

--

### É a **saída** de muitas funções que fazem **análises estatísticas**

--

background-image: url(https://raw.githubusercontent.com/mauriciovancine/curso-r/master/imagens/list.png)
background-size: 300px
background-position: 50% 95%

---

# 3.11 Estrutura dos objetos: list

## **6. List**: heterogêneo (*mais de um modo*) e unidimensional (*uma dimensão*)


```r
li &lt;- list(rep(1, 20), # vector
           factor(1, 1), # factor
           cbind(c(1, 2), c(1, 2))) # matrix
li
```

```
## [[1]]
##  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
## 
## [[2]]
## [1] 1
## Levels: 1
## 
## [[3]]
##      [,1] [,2]
## [1,]    1    1
## [2,]    2    2
```

---

class: inverse, middle, center

# Dúvidas?

---

class: clear, middle

## Maurício Vancine

&lt;br&gt;

Contatos:

|                                                                                           |                               |
| :---------------------------------------------------------------------------------------- | :---------------------------- |
| &lt;a href="mailto:mauricio.vancine@gmail.com"&gt;.RUred[&lt;i class="fa fa-envelope fa-fw"&gt;&lt;/i&gt;]  | mauricio.vancine@gmail.com    |
| &lt;a href="https://mauriciovancine.netlify.com/"&gt;.RUred[&lt;i class="fa fa-link fa-fw"&gt;&lt;/i&gt;]   | mauriciovancine.netlify.com   |
| &lt;a href="http://twitter.com/mauriciovancine"&gt;.RUred[&lt;i class="fa fa-twitter fa-fw"&gt;&lt;/i&gt;]  | @mauriciovancine              |
| &lt;a href="http://gitlab.com/mauriciovancine"&gt;.RUred[&lt;i class="fa fa-gitlab fa-fw"&gt;&lt;/i&gt;]    | @mauriciovancine              |
| &lt;a href="http://github.com/mauriciovancine"&gt;.RUred[&lt;i class="fa fa-github fa-fw"&gt;&lt;/i&gt;]    | @mauriciovancine              |

Slides criados via pacote [xaringan](https://github.com/yihui/xaringan) e tema [Metropolis](https://github.com/pat-s/xaringan-metropolis)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightLines": true,
"countIncrementalSlides": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
